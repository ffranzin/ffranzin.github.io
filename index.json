[{"categories":null,"contents":"","permalink":"https://ffranzin.github.io/publications/a-raster-based-approach-for-waterbodies-mesh-generation/","tags":["Mesh Generation","GIS","Large Scale"],"title":"A Raster-based Approach for Waterbodies Mesh Generation"},{"categories":null,"contents":"","permalink":"https://ffranzin.github.io/publications/accurate-real-time-physics-simulation-for-large-worlds/","tags":["Real-time Physics Simulation","Physics Engines","Large scale","Floating-point Imprecision"],"title":"Accurate Real-time Physics Simulation for Large Worlds"},{"categories":null,"contents":"","permalink":"https://ffranzin.github.io/publications/gpu-based-rendering-and-collision-simulation-of-ground-vegetation-in-large-scace-virtual-scenarios/","tags":["Ground Vegetation","Collision Simulation","GPU-based","GPU-instancing","real-time","large scale"],"title":"GPU-Based Rendering and Collision Simulation of Ground Vegetation in Large-Scace Virtual Scenarios"},{"categories":null,"contents":"","permalink":"https://ffranzin.github.io/publications/procedural-editing-of-virtual-terrains-using-3d-bezier-curves/","tags":["Bezier Curves","procedural","carving","virtual terrains","spatial hashing"],"title":"Procedural Editing of Virtual Terrains Using 3D Bezier Curves"},{"categories":null,"contents":"","permalink":"https://ffranzin.github.io/publications/gpu-based-real-time-procedural-distribution-of-vegetation-on-large-scale-virtual-terrains/","tags":["Vegetation Distribution","Procedural","large scale","virtual terrains","real-time","GPU-based"],"title":"GPU-Based Real-Time Procedural Distribution of Vegetation On Large-Scale Virtual Terrains"},{"categories":null,"contents":"","permalink":"https://ffranzin.github.io/publications/uma-framework-para-distribuicao-gerenciamento-e-renderizacao-de-vegetacao-em-cenarios-virtuais-massivos-em-tempo-real/","tags":["Vegetation","procedural","Virtual Landscapes","Undergrowth Collision Simulation","GPU-Based","Large Scale","Real-Time"],"title":"Uma Framework para distribuicao, gerenciamento e renderizacao de vegetacao em cenarios virtuais massivos em tempo real"},{"categories":null,"contents":"","permalink":"https://ffranzin.github.io/publications/aplica%C3%A7%C3%A3o-de-t%C3%A9cnicas-procedurais-em-gpu-para-renderiza%C3%A7%C3%A3o-de-nuvens-volum%C3%A9tricas-em-tempo-real/","tags":["Clouds","Procedural","Ray Marching","Noise"],"title":"Aplicacao de tecnicas procedurais em GPU para renderizacao de nuvens volumetricas em tempo real"},{"categories":null,"contents":"","permalink":"https://ffranzin.github.io/publications/using-active-mediators-and-passive-extractors-inside-materialized-data-integration-systems/","tags":["Data extraction","data integration","data analysis automation"],"title":"Using Active Mediators and Passive Extractors Inside Materialized Data Integration Systems"},{"categories":null,"contents":"Intro Doesn\u0026rsquo;t matter whether it\u0026rsquo;s a CakePHP app for a client, your own personal CMS, or any other web based application. If your passing around passwords or other sensitive info you should really implement SSL. SSL provides 2 main perks to your visitors.\n First it encrypts all communication that flies across the web. This prevents curious or devious billies from getting your secrets. Secondly it ensures to the user that your server is in fact who it claims, and not a nasty \u0026lsquo;man in the middle\u0026quot; attack. Finally it gives your site that touch of class\u0026hellip;. which of course a classy person like yourself relies on.  Once you implement SSL certificates on your server you\u0026rsquo;ll want to require secure connections using Apache\u0026rsquo;s rewrite module. Now I won\u0026rsquo;t dwell on the creation and signing of certificates, its already well documented. If your just starting out though,heres a few links I recommend;\n Creating self-signed certificates (free, but should only be used internally or for testing, users will; see an \u0026lsquo;Untrusted\u0026quot; warning) Requesting a CA Signed certificate (not free, but the final certificate is trusted and seamless for users)  The second link uses the schools internal CA, you will need to pay a public CA like Entrust or Verisign. All of this information is aimed at \u0026lsquo;nix or solaris servers running apache. Why? cause a production windows server is laughable :-p\nNow that you have a certificate, whats next? So there you are you have a shiny new Certificate and Server key, how do you force visitors to your apache driven site to use the SSL? You copied the certificates into the appropite locations right? And you have made the needed changes in httpd.conf right? So now when you view https://example.com you see a \u0026lsquo;trusted\u0026rsquo; warning or your site right? If No to any of these than this article does a pretty good job of outlining those steps.\nThe SSL Works, How do I force connections to use it? First you need to decide if you want to force every page on your site to use SSL, or only a particular sub-domain, or maybe just your admin directory. Since the overhead is minimal there is no harm is forcing the entire domain to leverage SSL, but if it is a self-signed certificate for your personal use than you\u0026rsquo;ll most certainly want to restrict its use to your own areas. This prevents users from seeing that nasty warning \u0026ldquo;This server is not trusted\u0026rdquo; You\u0026rsquo;ll know if your using SSL because the url prefix changes from http to https (s for secure).\nForcing entire domain to use SSL You want any visit, any where to use ssl. This probably the simplest solution. Create or append to your htaccess file in the top directory of your server. Some people use a port check (80 is typically http, while 443 is https) but if you have alernate configs or the user just adds :8080 to the end of the url this method is useless. Instead check whether the https environmental variable is set, if not then redirect.\nRewriteCond %{HTTPS} !=on RewriteRule ^(.*)$ https://%{SERVER_NAME}$1 \\[R,L\\] Forcing sub-domains to use SSL Maybe you only want mysecretarea.example.com to use SSL, that\u0026rsquo;s easy enough. Its the same premise as above, but you move the htaccess file into the directory that corresponds to the subdomain. Also change the second line like below;\nRewriteCond %{HTTPS} !=on RewriteRule ^(.*)$ https://mysecretarea.%{SERVER_NAME}$1 \\[R,L\\] Forcing a directory to use SSL This method cn get a little hairier if your using aliases or redirects on top of this one. You\u0026rsquo;ll need to consider what order the commands are read. The basic principle is like so. You want all visits to example.com/admin to use ssl. Create a htaccess file in the parent directory. Again will check for the https variable, but this time we also check for the sub-directory to be in the path.\nRewriteCond %{HTTPS} !=on RewriteRule ^/admin/(.*)$ https://%{SERVER_NAME}/admin/$1 \\[R,L\\] ","permalink":"https://ffranzin.github.io/blog/force-ssl/","tags":["apache","apache","redirect","rewrite","ssl","web development"],"title":"Forcing Visits to use SSL"},{"categories":null,"contents":" * { box-sizing: border-box; } .img-container-x4 { float: left; width: 25%; padding: 1px; } .img-container-x4:hover img { float: left; width: 150%; padding: 1px; } .clearfix::after { content: \"\"; clear: both; display: table; }  \nMossberg\n     \nGranade Launcher L79\n      \nBarrett m107\n \nFlamethrower\n      \nBBS-CM\n      \nVehicles MK-6\n      \nAged Wood\n    \nGround with Roots\n    \nMuddy with Trails\n    \nMechanical arm with Inverse kinematics\n  \nProcedural vehicle\u0026rsquo;s dirt based on movement\n  \nVehicle leveling\n    --  ","permalink":"https://ffranzin.github.io/projects/creations/art-and-tech-art/","tags":["Substance Painter","Substance Designer","Blender","ZBrush","UV unwrapping","Texturing","Sculpting","Procedural Material","Shader","programming"],"title":"Art and tech-art"},{"categories":null,"contents":" .center { display: block; margin-left: auto; margin-right: auto; max-width: 95%; } .row { display: flex; margin-left: auto; margin-right: auto; max-width: 95%; } .column { flex: 25%; padding: 2px; } video { width: 70%; height: auto; display: block; margin-left: auto; margin-right: auto; } #player-overlay { position: absolute; display: none; top: 0; left: 0; width: 100%; height: 100%; background-color: #000 z-index:999; }  I prototyped two solutions to break glass in games. In order to exploit my knowledge, both approaches were developed only based on my expertise and problem-solving skills.\n\nDescription\nTechnique 1 - Projecting broken glass patterns in screen space\nThis approach is designed to simulate broken glass from projectiles (e.g., gunshots). The process consists of detecting impact points with glass surfaces -using raycasts- and projecting some patterns of broken glass around them. The process is entirely done in screen-space, ensuring a correct projection of the patterns even for non-static glass surfaces.\n\nTechnique 2 - Procedural broken glass\nThis approach is designed to break larger areas of glass using objects (e.g., stones). For this, a mask and a pattern are used to simulate broken glass. When an object is thrown, many processes are done to update the mask relative to the destroyed region. We also deal with what we call Floating Zones: glass without contact with another surface. For example, in the image below, it is possible to note that the central region of glass will also be destroyed by destroying the only area in contact with the wall.\n\nResults\nBelow we have a short video demonstrating the results obtained. It is important to highlight that it is essential to use a particle system (or similar approaches) to generate shards of glass for more immersive effects.\n ","permalink":"https://ffranzin.github.io/projects/creations/breaking-glass/","tags":["Compute Shaders","Computer Graphics","Procedural","Shader","Real-time","Collision Simulation"],"title":"Break Glass"},{"categories":null,"contents":" * { box-sizing: border-box; } .img-container { float: left; width: 49%; padding: 2px; } .clearfix::after { content: \"\"; clear: both; display: table; } .center { display: block; margin-left: auto; margin-right: auto; max-width: 70%; } #vertical-line { float: left; height: 500px; width: 1px; background-color: black; } .vertical-line { border-right:1px solid #000; }  I encouraged managers and guided artists in optimizing 3D assets and game scenarios to create real-time cutscenes, avoiding several days of rendering after changes.\n\nMotivation\nDue to over-detailed 3D assets, we rendered offline cutscenes for game animations. As a result, minor changes took days to re-render these cutscenes. In addition, it is common to receive change requests of the client, increasing headaches and rework.\n\nBriefly Description\nI performed optimizations tests for proof-of-concept and introduced a new approach for managers and colleagues, rendering the entire scenario in real-time. From there, I guided artists to optimize 3D assets and game scenarios.\nInitially, we combine objects' meshes and textures to reduce the number of objects and materials to reduce draw-calls. In a second moment, we worked with the objects' geometries, which had an immense amount of vertices and also a disparity between object size and level of detail. Many small and occluded objects had an extreme level of detail, adding a high rendering cost. Below, we demonstrate a comparison of the before (left) and after (right) improvements applied to one of the 3D models.\n   \n There were also significant gains in the vehicle\u0026rsquo;s internal, but it cannot be shown for privacy reasons.\n \nResults\nAfter the improvements, the cutscenes were converted to animations running in real-time using the Unity engine. Changes are now far manageable and less time-consuming. It is also possible to keep software up to date as new technologies emerge, including new rendering methods or resolutions (e.g., full HD, 4K). All this is possible through a simple game\u0026rsquo;s rebuild instead of hours -or even days- of rendering.\n","permalink":"https://ffranzin.github.io/projects/creations/game-assets-optimizations/","tags":["Optimization","Performance","Tutoring","Real-time"],"title":"Game Assets Optimizations"},{"categories":null,"contents":" * { box-sizing: border-box; } .video-container { float: left; width: 50%; padding: 2px; } .clearfix::after { content: \"\"; clear: both; display: table; } .center { display: block; margin-left: auto; margin-right: auto; max-width: 50%; } video { width: 99%; height: auto; display: block; margin-left: auto; margin-right: auto; }  New requirements significantly increased the number of simulated game entities, putting the game at a critical stage in terms of performance. In this context, I took responsibility for investigating and fixing performance bottlenecks.\n\nBriefly Description\nI performed a scan of several game components such as audio sources, animators, particle systems, and entities' controllers to identify bottlenecks and apply improvements. These components were optimized using Event Systems, and others were disabled according to the objects' distance to the camera - very appropriate since entities are placed sparsely.\nOur physics simulation uses an intermediate Layer between PhysX and Unity to deal with the loss of numerical precision in large-scale scenarios (more details). With new entities being physically simulated, the solution presented what was already expected: scalability problems. In this context, I assumed the responsibility for identifying improvements for it. After studying how physical simulations work, I identified some issues. It was mostly related to PhysX\u0026rsquo;s data structures and continuous cache miss caused by our Layer. To solve the problem, I changed the Layer approach to minimize architectural conflicts with PhysX. After taking the new approach, I\u0026rsquo;ve also refactored some entities and behaviors to keep the simulation working correctly.\n\nResults\nAfter four months of massive refactoring, optimizing codes, and creating acceleration data structures, performance returned to a level capable of supporting the client\u0026rsquo;s new requirements. In addition, many of the decisions have increased the game\u0026rsquo;s scalability for future needs.\natualizar video..\nThe video below focuses on the physics improvements, which causes the more significant performance gains. It shows some test cases simulating 4 ASTROS batteries (composed of ~14 military vehicles each). Initially, the video demonstrates the impact of our physics Layer used to deal with the problem of numerical accuracy in large-scale scenarios. Then, some test cases moving the convoys. It is possible to notice that the movement of some objects already made the application almost unusable. After the improvements, it is possible to see a significant evolution in the performance aspect. On the left are shown before and on the right after the refactorings.\n \n It is essential to highlight that the computer where the tests were done has low computational power compared to the client.\n ","permalink":"https://ffranzin.github.io/projects/creations/game-optimizations/","tags":["Optimization","Performance","Memory Management","Data Structure"],"title":"Game Optimizations"},{"categories":null,"contents":" * { box-sizing: border-box; } .img-container { float: left; width: 25%; padding: 2px; } .video-container { float: left; width: 50%; padding: 2px; } .clearfix::after { content: \"\"; clear: both; display: table; } .center { display: block; margin-left: auto; margin-right: auto; max-width: 50%; }  I developed a solution for the real-time long-lasting grasses deformation and terrain trails according to the vehicles' and characters' movements. This is kept throughout the simulation with little memory overhead.\n\nMotivation\nIn the context of our client -military simulations-, the deformation of terrains and grasses according to the movement of military vehicles is extremely dangerous, as this can reveal your presence to the enemy. By the development team side, this functionality was desired but always discarded due to several problems. The main one was the incalculable storage cost to deform grams and keep them bent for many hours or even days of simulation.\nBelieving it is possible and moved by the ambition to develop a challenger feature, I thought of an alternative solution with low storage demand. The approach was prototyped and presented to the customer, who aroused a lot of interest. After that, the solution was improved and integrated into the application.\n\nSolution\nIn the proposed solution, the virtual scenario is segmented using a quadtree. When a quadtree node is visited by some dynamic object, a vector field \u0026ndash;maintained in 2D texture\u0026ndash; is assigned for it. For performance purposes, vector fields are deformed by planes and spheres, which approximate complex 3D objects.\nWhen objects move across the scenario, the vector of vector fields is deformed (image below), considering the direction and speed of the collider(s). Once bent, each vector receives a restoration cost according to empirical configurations assigned to the colliders. For example, the above tank\u0026rsquo;s colliders can damage the plants distinctly, where the colliders of the base only bent plants for a short moment, and the tracks colliders bent the plants for a very long time (we show this behavior in results).\n\nIn the vertex shader, grasses and small shrubs sample the vector fields to identify their orientation based on the interpolation of the closest vectors. Below we have a color debug showing the direction of the vectors in the vector fields after moving a vehicle. Also, we have the result after rendering, showing the vehicle\u0026rsquo;s path.\n     To texture the terrain, the process is similar. In the fragment shader, is made a simple cross product with up_vector and the sample in the vector field corresponding to the fragment\u0026rsquo;s world position. The result is a scalar value used to cause a simple distortion in the fragment\u0026rsquo;s color, keeping deformation continuity in far regions without 3D grams. The two images on the left show the before and after vehicles' movement, highlighting the path by terrain\u0026rsquo;s texturing. The two images on the right show the importance of the trails projected on terrain to improve the blend of deformed grams with the terrain.\n     When a quadtree is unrefined, nodes are destroyed -due to the CDLOD technique- and its vector fields are compressed \u0026ndash;using the LZ4 algorithm. When a node is (re)created, we check the existence of a compressed vector field belonging to the region delimited by the node. If yes, then this vector field is decompressed. In this way, it is possible to maintain deformations for long periods with a low storage cost. Bellow, we have the gains obtained for the vector fields compression.\n\nDue to the high parallelism of the task, compute-shaders were used in several processes; in addition, LOD and GPU-instancing techniques were used to optimize plants' rendering. Non-compressed vector fields are kept in a TextureAtlas to reuse memory, preventing allocations and memory fragmentation.\n\nResults\nI developed a challenging feature that caught the attention of the client. The developed solution went beyond state of the art, allowing deform grasses for long periods with a low storage cost.\nBelow, on the left, is shown a demonstration with several colliders interacting with the plants simultaneously. On the right, an example of a vehicle interacting with plants. Note that plants that interact with the base reestablish their original form more quickly than plants that interact with the tank\u0026rsquo;s tracks.\n    \nMore details can be seen here.\n","permalink":"https://ffranzin.github.io/projects/creations/grass-and-terrain-deformation/","tags":["Memory Management","Compute shaders","Computer graphics","Shader","Data compression","Real-time","GPU-Based","Collision Simulation","Large-Scale scenario"],"title":"Grass Deformation and Terrain Trails"},{"categories":null,"contents":" * { box-sizing: border-box; } .img-container-x4 { float: left; width: 25%; padding: 1px; } .img-container-x4:hover img { float: left; width: 150%; padding: 1px; } .clearfix::after { content: \"\"; clear: both; display: table; } .center { display: block; margin-left: auto; margin-right: auto; max-width: 85%; }  I modeled a set of 3D bridges parts to compose a procedural bridge system, instantiated in the scenario based on a starting and an ending point.\n\nDescription\nWith knowledge in programming and modeling, my participation in developing this functionality was essential to create accurate assets to allow a simple and maintainable solution. In addition, as another colleague did the coding, communication was also a decisive factor for the development.\nI modeled a set of edges and internal parts of bridges. During game loading, bridges are initialized based on a start and an endpoint. We also deal with bridges' colliders, allowing vehicles to travel over the bridges.\n\nResults\nBelow are four variations of bridges, created based on existing examples within the Brazilian Army\u0026rsquo;s training fields in Goias/Brazil. We also have a comparison of changing the starting and ending points of one bridge.\n     \u0026#8595;\n  ","permalink":"https://ffranzin.github.io/projects/creations/procedural-bridge-system/","tags":["Procedural","Modeling","UV unwrapping","Texturing"],"title":"Procedural Bridge System"},{"categories":null,"contents":" * { box-sizing: border-box; } .img-container-x4 { float: left; width: 33%; padding: 1px; } .img-container-x4:hover img { float: left; width: 150%; padding: 1px; } .clearfix::after { content: \"\"; clear: both; display: table; } video { width: 70%; height: auto; display: block; margin-left: auto; margin-right: auto; }  To solve the limitations of an existing solution, I designed and developed a robust GPU-based vegetation system capable of handling thousands of trees and small plants efficiently in real-time.\n Motivation\nSmall environments are usually decorated by an artist or designer, which allows for fine control and pleasant-looking results. However, this process tends to be time-consuming and can quickly become impractical as the size of the environment increases. To deal with this, procedural solutions are commonly adopted as they speed up the process. Therefore, a solution was developed to distribute trees to the entire scenario and store the result for future use. However, the solution didn\u0026rsquo;t allow artists' editing and was completely CPU-based. The non-use of parallelism and the constant data transfers between CPU→GPU were the main factors that negatively impacted the performance. Distribution was CPU-based and offline, where minor changes required hours to redistribute and save the result. The solution was limited to distributing large and medium-sized trees to minimize application loading cost and memory consumption.\nIn this context, I designed and developed a new solution to manage vegetation in large-scale scenarios, solving the main limitations of an existing solution.\n Solution\nThe solution distributes vegetation procedurally on-demand in regions delimited by quadtree\u0026rsquo;s nodes. Nodes outside the camera\u0026rsquo;s frustum are destroyed as well as the plants of it. The plants remain in memory as long as the nodes are visible. If needed, the plants are deterministically redistributed as the nodes are recreated.\nFor distribution, the solution considers the influence of different aspects, such as terrain (e.g., slope and moisture), environmental (e.g., forest, lakes, and rivers zones), and human (e.g., villages and roads) aspects. These aspects must be normalizable values into [0, 1] for any scenario\u0026rsquo;s portion. It is possible to use maps that indicate some information (e.g., precipitation and moisture level). In addition, it is also possible to use vector data, where normalized distances can indicate whether a scenario\u0026rsquo;s position is inside, outside, or in a transition region to some area, such as road, river (delimited by polylines); or, lakes, forests, villages (delimited by polygons).\n The solution can integrate any information discretized into [0-1] relevant for the plants' distribution.\n Plants are grouped using the concept of presets, characterized by a set of plants that share the same needs, considering distribution aspects and other fields used to exist in some scenario\u0026rsquo;s position. For example, a presets of plants that exist in 1) forest zones, 2) not in steep regions, and 3) in higher altitude regions. The system analyzes many presets in real-time and defines which preset best fits a particular scenario\u0026rsquo;s position. After determining the best presets for the analyzed position, any plant from that can be randomly selected to be placed.\nFor efficiency purposes, plants are analyzed frame-by-frame to establish a LOD to balance performance and visuals. The LOD is defined from the distance of each plant to the camera \u0026ndash;artists have control over it. Also, plants outside the frustum are discarded before rendering. Finally, plants' data are appropriately organized to speed up the rendering using GPU-Instancing.\nEven though vegetation processing takes place mainly on the GPU, other processes on the CPU can still interact with plants. Objects can deform grass and small bushes, keeping them bent for long periods with acceptable memory demands (see more details here). Plants' colliders are instanced on-demand based on physics objects' positions to allow collisions with large and medium-sized trees using the physics engine.\n   Results\nA scalable GPU-based solution was developed to deal with any type of plant (e.g., trees, bushes, and grass) in real-time. It is possible to save different configurations \u0026ndash;equivalent to biomes\u0026ndash; and use them in different scenarios. Artists can intuitively edit these configurations to get different layouts for plant placement, previewing the result immediately. In addition, artists can edit LOD parameters to get a trade-off between visuals and performance. The solution also extracts maximum parallelism and processing from modern GPUs. It also avoids as much data transfer between CPU↔GPUs as possible.\nBelow we have four examples of created biomes.\n                     Below it is possible to see the rendering of several plants in a long-distance view.\n     Below we have a short performance demonstration.\n ","permalink":"https://ffranzin.github.io/projects/creations/procedural-vegetation-system/","tags":["Procedural","Compute shaders","Computer graphics","Shader","Real-time","GPU-Based","GPU-Instancing","Large-Scale scenario"],"title":"Procedural Vegetation System"},{"categories":null,"contents":"This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml\n[outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;JSON\u0026#34;] Searching additional fileds To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category\n... \u0026#34;contents\u0026#34;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026#34;tags\u0026#34;:{{ .Params.tags | jsonify }}{{end}}, \u0026#34;categories\u0026#34; : {{ .Params.categories | jsonify }}, ... Edit fuse.js options to Search static/js/search.js\nkeys: [ \u0026#34;title\u0026#34;, \u0026#34;contents\u0026#34;, \u0026#34;tags\u0026#34;, \u0026#34;categories\u0026#34; ] ","permalink":"https://ffranzin.github.io/search/","tags":null,"title":"Search Results"},{"categories":null,"contents":" video { width: 70%; height: auto; display: block; margin-left: auto; margin-right: auto; } #player-overlay { position: absolute; display: none; top: 0; left: 0; width: 100%; height: 100%; background-color: #000 z-index:999; }  I developed a dynamic structure to optimize access to mass datasets of polygons and polylines, representing areas like forests, lakes, roads, and rivers. This structure accelerated the terrain rendering ーwhich these data are projected by texturingー by +80% on average.\n\nMotivation\nIn military simulations, it is common to use vector data representing natural or human elements of the real world, such as rivers, roads, highways, lakes, forests, and wetlands. These can be represented by hundreds or thousands of polylines or polygons, making the access extremely costly. Acceleration structures (e.g., hash, BVH, and quadtree) are widely used to minimize this cost. The efficiency of these structures is proportional to their refinement \u0026ndash;the area and/or the number of entities encapsulated by each structure\u0026rsquo;s unit. However, in large scenarios, this refinement is limited due to the high memory consumption.\nThe purpose of these structures is to break a large dataset into several small ones to access a smaller dataset and thus ensure greater access efficiency. However, there is still a considerable cost to access or traverse the structures and the data they encapsulate. In this context, I developed a middle layer structure to reduce access by shaders to the acceleration structures.\n\nSolution\nThe terrain is rendered in blocks using a quadtree and the CDLOD technique. For this, a dynamic structure was created, linked to the quadtree nodes – called Vector Data Map or simply Map. The Map is represented by a texture assigned to each quadtree’s node during its initialization. The texture covers the same region bounded by the quadtree’s node, and each pixel covers a small portion of that region. Each pixel encodes the presence of one or more vector data at two levels: Fully or Partially inside.\nThe purpose of the Map is to indicate the absence of a particular vector data quickly. For example, it is necessary to access the acceleration structures to texturize roads, identifying whether a specific fragment is inside or outside a road. In this case, it is common to get a negative result, meaning that most fragments will be out of a road. In this way, the fragment could quickly be assigned a ground texture rather than a road texture. The cost of this computation is O(1) per fragment that samples the Map and gets the result as True for Fully-Inside and false for Partially-Inside of some vector data. Only fragments that test true for Partially-Inside need to access the acceleration structures. However, the number of cases that fall into this case is generally smaller.\nA bitmask is used to reduce memory consumption, encoding four types of vector data per byte. Furthermore, each texture has a fixed resolution, regardless of the node’s depth it is being linked to, working similarly to a mipmap – nodes close to the camera have higher resolution. Also, TextureAtlas is used to avoid constant locations and avoid memory fragmentation.\nThe video below compares the access (red fragments) to the acceleration structures before and after the proposed structure. Note that when the Map is enabled, the access to acceleration structures decreases drastically.\n \n It is important to note that the Map is different from a splat-maps, which encodes a material rather than information for a given vector data. Splat-maps need a high resolution to get a satisfactory result. The structure presented has no impact on the visualization since the rendering remains vectorial, and the resolution adopted by the Map only impacts performance gains. In addition, the Map\u0026rsquo;s memory consumption is smaller, as it stores up to four types of vector data per byte instead of 1 material per byte, as in the case of a splat-map.\n \nResults\nWhen the proposed structure is enabled, the access to acceleration structures is considerably reduced. As a result, performance increases, which doubles in most cases. See the video below.\n ","permalink":"https://ffranzin.github.io/projects/creations/vector-feature-map/","tags":["Memory Management","Compute shaders","Computer graphics","Shaders","Data compression","Real-time","GPU-Based","Collision Simulation","Large-Scale Scenario"],"title":"Vector Data Access Optimization"},{"categories":null,"contents":" .center { display: block; margin-left: auto; margin-right: auto; max-width: 95%; } .row { display: flex; margin-left: auto; margin-right: auto; max-width: 95%; } .column { flex: 25%; padding: 2px; }  I designed and guided an intern in developing a tool to generate polygonal meshes from mass polygons and polylines datasets, used to represent water planes for lakes and rivers in 3D scenarios.\n\nMotivation\nThis tool was developed to replace an old solution, which had problems with the scalability between junctions of entities, such as river-river (line-line, in the left), rivers-rivers (lines-lines, in the middle), and river-lake (line-polygon, in the right). This solution took a geometric approach and treated each case of junctions, resulting in a low expandable and challenging to maintain.\n\nSolution\nTo get a simple and scalable solution for different types and amounts of entities' junctions, we developed a raster-based solution.\nThe process starts by filling a texture (Buffering step, image below), where each pixel represents a small portion of the scenario and is set as a region Inside, Outside, or Border of a water body (river and/or lake). Next, the texture is traversed to extract the pixels defined as a border (Vectorization step), which will be Simplified and Triangulated in the sequence. It results in a single mesh containing rivers and lakes from the region considered (whole scenario or small blocks for performance reasons). For performance purposes, compute-shader and acceleration structures were used.\n\nResults\nThe developed solution is simple and easy to maintain and doesn\u0026rsquo;t have restrictions on joining different amounts of rivers and lakes entities.\n\n\nMore details can be seen here.\n","permalink":"https://ffranzin.github.io/projects/creations/water-bodies-meshes-generation/","tags":["Compute Shaders","Computer Graphics","Data Structure","GIS Data","GPU-Based","Large-Scale scenario","Tools","Tutoring"],"title":"Water planes mesh generation"}]